# Helm-templates
Template for helm chart

When creating these templates, I was inspired by the chart-writing style of [Kong](https://github.com/Kong/charts)

In the [my-project](./my-project/) directory, you can find a template for creating a Helm chart.

Don't forget replace myproject and myservice to your project name and service name.

## Documentation
Templates for services and ingresses are used to ensure consistency during deployment. These templates are stored in the [_helpers.tpl](./my-project/templates/_helpers.tpl) file.

When deploying, you can specify the chart name and set the namespace where the chart will be deployed. The namespace can be overridden in [values.yaml](./my-project/values.yaml) by modifying the `namespace` variable.

To support multiple deployments of the application and ensure unique object names, all objects generated by Helm from the chart are prefixed with the release name. This value can be overridden by setting `fullnameOverride` in [values.yaml](./my-project/values.yaml).

If needed, additional labels can be applied to all objects in the cluster by adding them to `commonLabels` in [values.yaml](./my-project/values.yaml).

### Services
[_helpers.tpl](./my-project/templates/_helpers.tpl) contains templates for different types of services:

- myproject.loadBalancer    [myservice-loadbalancer.yaml](./my-project/templates/myservice-loadbalancer.yaml)
- myproject.nodePort        [myservice-nodeport.yaml](./my-project/templates/myservice-nodeport.yaml)
- myproject.ClusterIP       [myservice-service.yaml](./my-project/templates/myservice-service.yaml)

#### Port Range Generation
Due to the usage of Go templates in Helm, port generation is not a trivial task. Below is an example of port generation:
```
# Declare a list for ports
{{- $ports := list -}}
# If necessary, we can add a default port that will always be created
{{- $httpPort := dict -}}
{{- $_ := set $httpPort "name" "http" -}}
{{- $_ := set $httpPort "port" .Values.application.service.port -}}
{{- $_ := set $httpPort "targetPort" .Values.application.service.targetPort -}}
{{- $_ := set $httpPort "protocol" "TCP" -}}

# Check if port generation mode is enabled
{{- if or (eq .Values.application.service.mode "range") (eq .Values.application.service.mode "random") }}
# The most complex part: subtracting start from end to get
# the number of ports to create. `add1` is used to increase
# the count by 1, so the upper boundary is included. For
# some reason, Go templates do not treat this value as an
# integer, so we explicitly cast it to an integer. After
# that, we use `until` to generate a sequence from 0 to
# our value, and finally, we loop with `range`. In our case,
# `i` and `p` are equal, so it doesn't matter which value we use.
  {{- range $i, $p := until (add1 (sub .Values.application.service.range.end .Values.application.service.range.start) | int) }}
    # Create a local dictionary for a new port and fill it
    # with values
    {{- $udpPort := dict -}}
    # Generate the name
    {{- $_ := set $udpPort "name" ($i | printf "udp-%d") -}}
    # Add our value to the start to get the new `port` and
    # `targetPort`
    {{- $_ := set $udpPort "port" (add $.Values.application.service.range.start $i) -}}
    {{- $_ := set $udpPort "targetPort" (add $.Values.application.service.range.start $i) -}}
    {{- $_ := set $udpPort "protocol" "UDP" -}}
    # Finally, add the resulting dictionary to the list
    {{- $ports = append $ports $udpPort -}}
  {{- end }}
{{- end }}
```

### Ingress
For generating ingress resources, the template **myproject.ingress** in [_helpers.tpl](./my-project/templates/_helpers.tpl) is used and called in the [myservice-ingress.yaml](./my-project/templates/myservice-ingress.yaml) file. Additionally, the [myservice-ingress.yaml](./my-project/templates/myservice-ingress.yaml) file contains logic to generate the hosts section and override the default value if a relevant parameter is added in [values.yaml](./my-project/values.yaml).

### Roles and ClusterRoles
Files [cluster-role-binding-myservice.yaml](./my-project/templates/cluster-role-binding-myservice.yaml) and [role-binding.yaml](./my-project/templates/role-binding.yaml) contain examples of role bindings.  
Files [role.yaml](./my-project/templates/role.yaml) and [cluster-role-myservice.yaml](./my-project/templates/cluster-role-myservice.yaml) contain examples of roles.

### ServiceMonitoring
To generate a `ServiceMonitor` or `VMServiceScrape`, the template **myproject.ServiceMonitoring** in [_helpers.tpl](./my-project/templates/_helpers.tpl) is used and called in the [myservice-servicemonitoring.yaml](./my-project/templates/myservice-servicemonitoring.yaml) file. The configuration for `ServiceMonitor` and `VMServiceScrape` is located in the metrics section of each application in [values.yaml](./my-project/values.yaml).

Here's the corrected version of your sentence:

The template allows you to choose between Prometheus and VictoriaMetrics using the `provider` variable from the metrics section.

> ⚠️ **Warning**: For the creation of this entity, the necessary CRDs must be installed alongside Prometheus/VictoriaMetrics.